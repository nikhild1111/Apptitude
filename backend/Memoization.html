<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Memoization Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-align: center;
            border-bottom: 3px solid #667eea;
            padding-bottom: 15px;
        }

        h2 {
            color: #764ba2;
            font-size: 1.8em;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-left: 15px;
            border-left: 5px solid #764ba2;
        }

        h3 {
            color: #5a67d8;
            font-size: 1.4em;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        p {
            margin-bottom: 15px;
            font-size: 1.05em;
        }

        .emoji-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            font-size: 1.1em;
            font-weight: 500;
        }

        .checkmark {
            background: #10b981;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .cross {
            background: #ef4444;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .warning {
            background: #f59e0b;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .info {
            background: #3b82f6;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        pre {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        code {
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }

        .highlight {
            background: #fef3c7;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
            font-size: 1.05em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e5e7eb;
        }

        tr:hover {
            background: #f3f4f6;
        }

        .step-box {
            background: #f0f9ff;
            border-left: 4px solid #3b82f6;
            padding: 15px 20px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .note-box {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .section {
            margin-bottom: 50px;
        }

        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin-right: 10px;
        }

        .badge-green {
            background: #10b981;
            color: white;
        }

        .badge-red {
            background: #ef4444;
            color: white;
        }

        .badge-blue {
            background: #3b82f6;
            color: white;
        }

        .badge-purple {
            background: #8b5cf6;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§  What is Memoization in React?</h1>

        <div class="section">
            <div class="emoji-box">
                âœ… <strong>What is Memoization?</strong><br>
                Memoization is an optimization technique where React stores (remembers) the result of a calculation, component, or function and reuses it instead of recalculating it again.
            </div>

            <div class="info">
                ğŸ‘‰ <strong>In simple words:</strong> If input is same â†’ reuse old result â†’ save time & performance
            </div>
        </div>

        <div class="section">
            <h2>â“ Why do we need Memoization in React?</h2>
            <p>In React:</p>
            <ul>
                <li>Components re-render often</li>
                <li>Expensive calculations run again and again</li>
                <li>Child components re-render even when props are same</li>
            </ul>
            <div class="cross">ğŸ”´ This causes performance issues</div>
            <div class="checkmark">ğŸŸ¢ Memoization prevents unnecessary re-renders and calculations</div>
        </div>

        <div class="section">
            <h2>ğŸ§© Types of Memoization in React</h2>
            <div class="step-box">
                <strong>1ï¸âƒ£ React.memo</strong> â†’ memoize component<br>
                <strong>2ï¸âƒ£ useMemo</strong> â†’ memoize value<br>
                <strong>3ï¸âƒ£ useCallback</strong> â†’ memoize function
            </div>
        </div>

        <div class="section">
            <h2>1ï¸âƒ£ React.memo (Component Memoization)</h2>
            <p>Prevents re-render of a component if props are same.</p>
            
            <pre><code>const Child = React.memo(({ name }) => {
  console.log("Child rendered");
  return &lt;div&gt;Hello {name}&lt;/div&gt;;
});</code></pre>

            <div class="info">ğŸ‘‰ Child will re-render only if <span class="highlight">name</span> changes</div>

            <h3>ğŸ” Normal React Behavior (WITHOUT React.memo)</h3>
            <div class="warning">
                ğŸ‘‰ <strong>Rule:</strong> When Parent component re-renders â†’ all Child components also re-render by default<br><br>
                Even if:
                <ul style="margin-top: 10px;">
                    <li>Child props are same</li>
                    <li>Child UI does not change</li>
                </ul>
            </div>

            <div class="note-box">
                <strong>Yes, even if Child is in a separate file and imported, the behavior is EXACTLY the same.</strong>
            </div>
        </div>

        <div class="section">
            <h2>ğŸ§  Very Important Concept (Key Point)</h2>
            <div class="emoji-box">
                React does NOT care about files. React only cares about the component tree.
            </div>

            <p>Whether:</p>
            <ul>
                <li>Child is in the same file OR</li>
                <li>Child is in a different file and imported</li>
            </ul>
            <div class="info">ğŸ‘‰ Re-render behavior is the SAME</div>

            <h3>ğŸ§© Example with Separate Files</h3>
            
            <p><strong>ğŸ“ Parent.jsx</strong></p>
            <pre><code>import Child from "./Child";

function Parent() {
  const [count, setCount] = React.useState(0);
  
  return (
    &lt;&gt;
      &lt;Child name="Nikhil" /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}

export default Parent;</code></pre>

            <p><strong>ğŸ“ Child.jsx</strong></p>
            <pre><code>function Child({ name }) {
  console.log("Child rendered");
  return &lt;div&gt;Hello {name}&lt;/div&gt;;
}

export default Child;</code></pre>

            <h3>ğŸ” What happens when you click the button?</h3>
            <p><strong>Step-by-step:</strong></p>
            <div class="step-box">
                1ï¸âƒ£ setCount is called<br>
                2ï¸âƒ£ count changes<br>
                3ï¸âƒ£ Parent component re-renders<br>
                4ï¸âƒ£ Parent JSX runs again<br>
                5ï¸âƒ£ React sees &lt;Child name="Nikhil" /&gt; again<br>
                6ï¸âƒ£ âŒ Child component function is CALLED again<br>
                7ï¸âƒ£ Console prints â†’ "Child rendered"
            </div>
            <div class="cross">ğŸ‘‰ Even though name did not change</div>

            <h3>â“ WHY does this happen even with separate files?</h3>
            <p><strong>Because:</strong></p>
            <ul>
                <li>Importing a component just gives React a reference</li>
                <li>On every Parent render, React:
                    <ul>
                        <li>Executes Parent function</li>
                        <li>Rebuilds JSX tree</li>
                        <li>Calls Child function again</li>
                    </ul>
                </li>
            </ul>

            <div class="note-box">
                <strong>ğŸ“ File separation is ONLY for:</strong>
                <ul style="margin-top: 10px;">
                    <li>Code organization</li>
                    <li>Readability</li>
                    <li>Reusability</li>
                </ul>
                <div class="cross">âŒ It does NOT affect rendering behavior</div>
            </div>

            <h3>ğŸ§  Think Like This (Simple Analogy)</h3>
            <p>Think Parent render like this:</p>
            <pre><code>Parent() {
  return Child({ name: "Nikhil" });
}</code></pre>
            <div class="warning">Every Parent render â†’ Child is called again<br>File location âŒ doesn't matter</div>

            <h3>âœ… How to STOP Child re-render?</h3>
            <p><strong>Use React.memo</strong></p>
            
            <p><strong>ğŸ“ Child.jsx</strong></p>
            <pre><code>import React from "react";

const Child = React.memo(({ name }) => {
  console.log("Child rendered");
  return &lt;div&gt;Hello {name}&lt;/div&gt;;
});

export default Child;</code></pre>

            <h3>ğŸ” Now what happens?</h3>
            <div class="step-box">
                1ï¸âƒ£ Parent re-renders<br>
                2ï¸âƒ£ React checks Child props<br>
                3ï¸âƒ£ name is SAME âœ…<br>
                4ï¸âƒ£ Child render is SKIPPED<br>
                5ï¸âƒ£ Console will NOT print again
            </div>

            <h3>ğŸ§  How React.memo works internally (Simple)</h3>
            <ul>
                <li>It compares old props and new props</li>
                <li>Uses shallow comparison</li>
                <li>If props are equal â†’ skip re-render</li>
                <li>If props change â†’ re-render</li>
            </ul>

            <div class="note-box">
                <strong>ğŸ“Œ Important Note (Very Important for Interview)</strong><br><br>
                â— React.memo works ONLY for props<br><br>
                <div class="cross">âŒ It does NOT stop re-render if:</div>
                <ul style="margin-top: 10px;">
                    <li>Child has its own useState</li>
                    <li>Context value changes</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>2ï¸âƒ£ useMemo (Value Memoization)</h2>
            
            <div class="emoji-box">
                âœ… <strong>What is useMemo?</strong><br>
                useMemo is a React Hook used to remember (memoize) a calculated value so that React does not recalculate it on every re-render.
            </div>

            <div class="info">
                ğŸ‘‰ <strong>In simple words:</strong> useMemo stores the result of a calculation and reuses it until dependencies change.
            </div>

            <h3>â“ Why do we need useMemo?</h3>
            <p>In React:</p>
            <ul>
                <li>Component re-renders often</li>
                <li>Heavy / expensive calculations run again and again</li>
                <li>This causes performance issues</li>
            </ul>
            <div class="cross">ğŸ”´ Problem: Recalculation on every render</div>
            <div class="checkmark">ğŸŸ¢ Solution: useMemo</div>

            <h3>ğŸ§© Without useMemo (Problem)</h3>
            <pre><code>function App() {
  const [count, setCount] = React.useState(0);
  
  const total = heavyCalculation(1000); // runs on EVERY render âŒ
  
  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
      &lt;div&gt;{total}&lt;/div&gt;
    &lt;/&gt;
  );
}</code></pre>
            <div class="cross">ğŸ‘‰ Even clicking button (unrelated to total) recalculates it.</div>

            <h3>âœ… With useMemo (Best Practice)</h3>
            <pre><code>import { useMemo } from "react";

function App() {
  const [count, setCount] = React.useState(0);
  
  const total = useMemo(() => {
    return heavyCalculation(1000);
  }, []);
  
  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
      &lt;div&gt;{total}&lt;/div&gt;
    &lt;/&gt;
  );
}</code></pre>
            <div class="checkmark">âœ”ï¸ Calculation runs only once</div>

            <h3>ğŸ” useMemo with Dependency</h3>
            <pre><code>const total = useMemo(() => {
  return heavyCalculation(count);
}, [count]);</code></pre>
            <div class="checkmark">âœ”ï¸ Recalculates only when count changes</div>

            <h3>ğŸ§  How useMemo Works Internally (Simple)</h3>
            <ul>
                <li>React stores the returned value</li>
                <li>On next render:
                    <ul>
                        <li>If dependencies SAME â†’ reuse value</li>
                        <li>If dependencies CHANGE â†’ recalculate</li>
                    </ul>
                </li>
            </ul>

            <h3>ğŸ“ Where should you use useMemo?</h3>
            <div class="step-box">
                <strong>1ï¸âƒ£ Expensive calculations</strong>
                <ul style="margin-top: 10px;">
                    <li>Loops</li>
                    <li>Sorting</li>
                    <li>Filtering</li>
                    <li>Data processing</li>
                </ul>
            </div>
            <pre><code>const sortedList = useMemo(() => {
  return list.sort();
}, [list]);</code></pre>
        </div>

        <div class="section">
            <h2>3ï¸âƒ£ useCallback (Function Memoization)</h2>
            
            <div class="emoji-box">
                âœ… <strong>What is useCallback?</strong><br>
                useCallback is a React Hook that remembers (memoizes) a function so that React does not create a new function again and again on every re-render.
            </div>

            <div class="info">
                ğŸ‘‰ <strong>In simple words:</strong> useCallback saves a function and reuses it until its dependencies change.
            </div>

            <h3>â“ Why do we need useCallback?</h3>
            <p>In React:</p>
            <ul>
                <li>Every time a component re-renders, all functions inside it are recreated</li>
                <li>If we pass a function to a child component, React thinks it is a new function</li>
                <li>This causes unnecessary re-renders of child components</li>
            </ul>
            <div class="cross">ğŸ”´ Problem: Performance issue</div>
            <div class="checkmark">ğŸŸ¢ Solution: useCallback</div>

            <h3>ğŸ” Example without useCallback (Problem)</h3>
            <pre><code>function Parent() {
  const [count, setCount] = React.useState(0);
  
  const handleClick = () => {
    console.log("Clicked");
  };
  
  return (
    &lt;&gt;
      &lt;Child onClick={handleClick} /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}</code></pre>
            <div class="cross">
                ğŸ‘‰ Every time count changes:
                <ul style="margin-top: 10px;">
                    <li>handleClick is recreated</li>
                    <li>Child re-renders even if not needed</li>
                </ul>
            </div>

            <h3>âœ… Example with useCallback (Best Practice)</h3>
            <pre><code>import { useCallback } from "react";

function Parent() {
  const [count, setCount] = React.useState(0);
  
  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []);
  
  return (
    &lt;&gt;
      &lt;Child onClick={handleClick} /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}</code></pre>
            <div class="checkmark">
                âœ”ï¸ Now:
                <ul style="margin-top: 10px;">
                    <li>handleClick is same function</li>
                    <li>Child does NOT re-render unnecessarily</li>
                </ul>
            </div>

            <h3>ğŸ“ Where should you use useCallback?</h3>
            <div class="step-box">
                <strong>1ï¸âƒ£ When passing a function to a child component</strong><br>
                Especially with React.memo<br><br>
                <code>export default React.memo(Child);</code>
            </div>

            <div class="step-box">
                <strong>2ï¸âƒ£ When function is used in dependency array (for useEffect, useMemo)</strong>
                <pre style="margin-top: 10px;"><code>const fetchData = useCallback(() => {
  // API call
}, []);

useEffect(() => {
  fetchData();
}, [fetchData]);</code></pre>
            </div>

            <div class="step-box">
                <strong>3ï¸âƒ£ Performance optimization in large apps</strong>
                <ul style="margin-top: 10px;">
                    <li>Dashboards</li>
                    <li>Tables</li>
                    <li>Lists</li>
                    <li>Reusable components</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>ğŸ“Š Comparison Table</h2>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>useMemo</th>
                        <th>useCallback</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>What it stores</strong></td>
                        <td>Value</td>
                        <td>Function</td>
                    </tr>
                    <tr>
                        <td><strong>Returns</strong></td>
                        <td>Value</td>
                        <td>Function</td>
                    </tr>
                    <tr>
                        <td><strong>Used for</strong></td>
                        <td>Heavy calculations</td>
                        <td>Function props</td>
                    </tr>
                    <tr>
                        <td><strong>Prevents</strong></td>
                        <td>Recalculation</td>
                        <td>Re-render</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>ğŸ§  useCallback + React.memo Together</h2>
            
            <h3>ğŸ§  First understand the BIG problem</h3>
            <div class="emoji-box">
                â“ <strong>What breaks React.memo?</strong><br><br>
                ğŸ‘‰ Function props
            </div>

            <p><strong>Because:</strong></p>
            <ul>
                <li>On every parent re-render</li>
                <li>A new function is created</li>
                <li>React thinks props changed</li>
                <li>React.memo fails âŒ</li>
            </ul>

            <h3>ğŸ”´ Problem Example (WITHOUT useCallback)</h3>
            <p><strong>Parent.jsx</strong></p>
            <pre><code>import Child from "./Child";

function Parent() {
  const [count, setCount] = React.useState(0);
  
  const handleClick = () => {
    console.log("Button clicked");
  };
  
  return (
    &lt;&gt;
      &lt;Child onClick={handleClick} /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}

export default Parent;</code></pre>

            <p><strong>Child.jsx</strong></p>
            <pre><code>const Child = React.memo(({ onClick }) => {
  console.log("Child rendered");
  return &lt;button onClick={onClick}&gt;Click me&lt;/button&gt;;
});

export default Child;</code></pre>

            <h3>âŒ What happens here?</h3>
            <div class="step-box">
                1ï¸âƒ£ Parent renders<br>
                2ï¸âƒ£ handleClick function is created<br>
                3ï¸âƒ£ Child renders<br><br>
                <strong>Click + button ğŸ‘‡</strong><br><br>
                4ï¸âƒ£ Parent re-renders<br>
                5ï¸âƒ£ âŒ NEW handleClick function is created<br>
                6ï¸âƒ£ Props changed (onClick reference changed)<br>
                7ï¸âƒ£ âŒ Child re-renders
            </div>
            <div class="cross">ğŸ‘‰ React.memo FAILS</div>

            <h3>âœ… Solution: useCallback</h3>
            <h3>ğŸŸ¢ Correct Example (WITH useCallback)</h3>
            <p><strong>Parent.jsx</strong></p>
            <pre><code>import { useCallback } from "react";
import Child from "./Child";

function Parent() {
  const [count, setCount] = React.useState(0);
  
  const handleClick = useCallback(() => {
    console.log("Button clicked");
  }, []);
  
  return (
    &lt;&gt;
      &lt;Child onClick={handleClick} /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}

export default Parent;</code></pre>

            <h3>ğŸ” Now what happens?</h3>
            <div class="step-box">
                <strong>First render:</strong><br>
                âœ”ï¸ Parent renders<br>
                âœ”ï¸ useCallback creates function once<br>
                âœ”ï¸ Child renders<br><br>
                
                <strong>Click + button:</strong><br>
                âœ”ï¸ Parent re-renders<br>
                âœ”ï¸ useCallback checks dependencies<br>
                âœ”ï¸ Dependencies SAME ([])<br>
                âœ”ï¸ Same function reference returned<br>
                âœ”ï¸ Props SAME<br>
                âœ”ï¸ âœ… Child render SKIPPED
            </div>
        </div>

        <div class="section">
            <h2>ğŸ§  WHEN is useCallback function re-created?</h2>
            
            <div class="emoji-box">
                ğŸ” <strong>Rule (Very Important)</strong><br>
                useCallback re-creates the function ONLY when dependency changes
            </div>

            <h3>Example with dependency</h3>
            <pre><code>const handleClick = useCallback(() => {
  console.log(count);
}, [count]);</code></pre>

            <h3>Behavior:</h3>
            <table>
                <thead>
                    <tr>
                        <th>Action</th>
                        <th>count changed?</th>
                        <th>function recreated?</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>First render</td>
                        <td>â€“</td>
                        <td><span class="badge badge-green">âœ… Yes</span></td>
                    </tr>
                    <tr>
                        <td>Click +</td>
                        <td>YES</td>
                        <td><span class="badge badge-green">âœ… Yes</span></td>
                    </tr>
                    <tr>
                        <td>No change</td>
                        <td>NO</td>
                        <td><span class="badge badge-red">âŒ No</span></td>
                    </tr>
                </tbody>
            </table>

            <h3>ğŸ§  What if dependency changes?</h3>
            <div class="step-box">
                ğŸ‘‰ New function reference<br>
                ğŸ‘‰ Child props change<br>
                ğŸ‘‰ React.memo allows re-render<br><br>
                <div class="checkmark">âœ”ï¸ This is correct behavior</div>
            </div>
        </div>

        <div class="section">
            <h2>ğŸ¯ Summary</h2>
            <div class="step-box">
                <p><span class="badge badge-purple">React.memo</span> â†’ Memoize component (prevents re-render if props same)</p>
                <p><span class="badge badge-blue">useMemo</span> â†’ Memoize value (caches calculation result)</p>
                <p><span class="badge badge-green">useCallback</span> â†’ Memoize function (caches function reference)</p>
            </div>

            <div class="note-box">
                <strong>ğŸ’¡ Pro Tip:</strong> Use these optimization techniques only when you have performance issues. Premature optimization can make your code more complex without significant benefits.
            </div>
        </div>
    </div>
</body>
</html>