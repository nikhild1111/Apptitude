<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Redis Guide - Interview Ready</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            border-left: 4px solid #667eea;
            padding-left: 20px;
        }

        h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        p {
            margin-bottom: 15px;
            font-size: 1.05em;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.5;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
            border-radius: 5px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table tr:hover {
            background: #f5f5f5;
        }

        .checkmark {
            color: #28a745;
            font-weight: bold;
        }

        .crossmark {
            color: #dc3545;
            font-weight: bold;
        }

        ul {
            margin: 15px 0 15px 30px;
        }

        li {
            margin-bottom: 10px;
            font-size: 1.05em;
        }

        .flow-diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            border: 2px dashed #667eea;
        }

        .flow-step {
            display: inline-block;
            margin: 5px;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border-radius: 25px;
            font-weight: 500;
        }

        .arrow {
            display: inline-block;
            margin: 0 10px;
            color: #667eea;
            font-size: 1.5em;
        }

        .note {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .example-box {
            background: #f1f8f4;
            border: 2px solid #28a745;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .example-box h4 {
            color: #28a745;
            margin-top: 0;
        }

        .key-points {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .key-points ul {
            margin-left: 20px;
        }

        .footer {
            background: #2d2d2d;
            color: white;
            padding: 30px;
            text-align: center;
        }

        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 600;
            margin: 5px;
        }

        .badge-success {
            background: #28a745;
            color: white;
        }

        .badge-info {
            background: #17a2b8;
            color: white;
        }

        .badge-warning {
            background: #ffc107;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚úÖ COMPLETE REDIS EXPLANATION</h1>
            <p>CLEAN + PERFECT + INTERVIEW-READY ‚≠ê</p>
        </div>

        <div class="content">
            <!-- Section 1 -->
            <div class="section">
                <h2>‚≠ê What is Redis?</h2>
                <p>Redis is an <strong>in-memory data store</strong>, meaning it's a database which stores data inside <strong>RAM</strong> instead of disk.</p>
                
                <div class="highlight">
                    <p><strong>MongoDB / SQL</strong> ‚Üí Disk storage ‚Üí slower</p>
                    <p><strong>Redis</strong> ‚Üí RAM storage ‚Üí extremely fast ‚ö°</p>
                </div>

                <h3>Because of this, Redis is used when you need:</h3>
                <ul>
                    <li>High speed</li>
                    <li>Temporary storage</li>
                    <li>Quick reads</li>
                    <li>Caching</li>
                    <li>Sessions / OTP / Rate limiting</li>
                </ul>

                <p>Redis stores everything in <strong>key-value format</strong>, which makes lookups very fast.</p>
            </div>

            <!-- Section 2 -->
            <div class="section">
                <h2>‚≠ê Why do we use Redis in a MERN E-commerce application?</h2>
                <p>In production, Redis is mostly used as <strong>cache memory</strong> and it even runs on a separate server.</p>

                <div class="example-box">
                    <h4>üìå Real Example:</h4>
                    <p>When a user hits an API ‚Üí the request goes to the backend ‚Üí we parse JSON ‚Üí we run a MongoDB query ‚Üí then send response.</p>
                    <p>This process is <strong>costly</strong> and takes time.</p>
                    <p>If the same user hits the same API again, the server again does the same work from scratch. This makes the application slow and increases response time.</p>
                </div>

                <h3>‚≠ê Redis solves this problem</h3>
                <p>Redis stores data in key-value format and acts as a cache.</p>

                <div class="note">
                    <h4>üí° Cache flow:</h4>
                    <p><strong>First request</strong> ‚Üí cache miss ‚Üí fetch from MongoDB ‚Üí send response ‚Üí store data in Redis with expiry (TTL)</p>
                    <p><strong>Next request</strong> ‚Üí cache hit ‚Üí Redis returns data instantly ‚Üí no MongoDB call needed ‚Üí response becomes super fast</p>
                </div>

                <h3>This improves:</h3>
                <ul>
                    <li>Response time</li>
                    <li>Server performance</li>
                    <li>User experience</li>
                </ul>

                <p>Redis stores the frequently requested data in RAM. So instead of hitting MongoDB every time, we first check Redis.</p>
            </div>

            <!-- Section 3 -->
            <div class="section">
                <h2>‚≠ê How Redis stores data</h2>
                <p>Redis stores everything as <strong>key-value pairs</strong> in memory.</p>

                <div class="example-box">
                    <h4>üìå Examples:</h4>
                    <div class="code-block">SET "products" "[...json data]" EX 3600 ‚Üí cache for 1 hour
SET "otp:9876543210" "1234" EX 120 ‚Üí OTP for 2 minutes
SET "session:userid123" "token" EX 86400 ‚Üí session for 1 day</div>
                </div>

                <p>Redis supports <strong>TTL (Time To Live)</strong> ‚Üí data auto-expires.</p>
                <p>It is used for temporary and fast-read operations.</p>
                <p><strong>Redis is NOT a persistent database.</strong> It's just for temporary data asked by users.</p>
            </div>

            <!-- Section 4 -->
            <div class="section">
                <h2>‚≠ê How We Use Redis in a MERN App (Step-by-Step)</h2>

                <h3>üîπ Step 1: Install Redis Server</h3>
                <div class="code-block">npm install ioredis</div>

                <h3>üîπ Step 2: Create Redis Connection File</h3>
                <p><strong>redis.js</strong></p>
                <div class="code-block">import Redis from "ioredis";

export const redis = new Redis({
  host: "127.0.0.1",
  port: 6379,
});</div>

                <h3>üîπ Step 3: Use Redis for Caching</h3>
                <div class="example-box">
                    <h4>üìå Example: Cache product list</h4>
                    <div class="code-block">app.get('/products', async (req, res) => {
  const cacheData = await redis.get("products");
  
  if (cacheData) {
    return res.json({ 
      source: "redis", 
      data: JSON.parse(cacheData) 
    });
  }
  
  const products = await Product.find();
  await redis.set("products", JSON.stringify(products), "EX", 3600);
  
  res.json({ 
    source: "mongodb", 
    data: products 
  });
});</div>
                </div>

                <h3>üîπ Step 4: Store Session or JWT</h3>
                <div class="code-block">await redis.set(`session:${userId}`, token, "EX", 86400); // 1 day</div>

                <h3>üîπ Step 5: OTP Storage</h3>
                <div class="code-block">await redis.set(`otp:${phone}`, otp, "EX", 120); // 2 minutes</div>

                <h3>üîπ Step 6: Rate Limiting</h3>
                <div class="code-block">const limit = async (req, res, next) => {
  const key = req.ip;
  const count = await redis.incr(key);
  
  if (count === 1) redis.expire(key, 60);
  
  if (count > 10) {
    return res.status(429).json({ msg: "Too many requests" });
  }
  
  next();
};</div>
            </div>

            <!-- Section 5 -->
            <div class="section">
                <h2>üß† What You Need to Learn for Redis in MERN?</h2>
                <div class="key-points">
                    <p><strong>Just these 6 topics:</strong></p>
                    <ul>
                        <li>What Redis is & why used</li>
                        <li>Basic Redis commands: SET, GET, DEL</li>
                        <li>EXPIRE, TTL</li>
                        <li>INCR, DECR</li>
                        <li>Using Redis with Node.js (ioredis)</li>
                        <li>Caching API responses</li>
                        <li>Session and OTP handling</li>
                        <li>Rate limiting</li>
                    </ul>
                </div>
                <p><strong>This is more than enough for interviews and real projects.</strong></p>
            </div>

            <!-- Section 6 -->
            <div class="section">
                <h2>üîπ Difference Between ioredis and redis (node-redis)</h2>
                
                <h3>1Ô∏è‚É£ Library Difference</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>ioredis</th>
                            <th>redis (node-redis)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Type</td>
                            <td>Advanced Redis client</td>
                            <td>Official Redis client</td>
                        </tr>
                        <tr>
                            <td>Async support</td>
                            <td>Built-in promises</td>
                            <td>Promises (v4+)</td>
                        </tr>
                        <tr>
                            <td>Cluster support</td>
                            <td><span class="checkmark">‚úÖ Best</span></td>
                            <td><span class="badge-warning">‚ö†Ô∏è Limited</span></td>
                        </tr>
                        <tr>
                            <td>Pub/Sub</td>
                            <td>Very stable</td>
                            <td>Stable</td>
                        </tr>
                        <tr>
                            <td>Auto reconnect</td>
                            <td><span class="checkmark">‚úÖ Yes</span></td>
                            <td><span class="checkmark">‚úÖ Yes</span></td>
                        </tr>
                        <tr>
                            <td>Production usage</td>
                            <td>High (preferred)</td>
                            <td>High</td>
                        </tr>
                    </tbody>
                </table>

                <h3>2Ô∏è‚É£ Connection Style Difference</h3>
                
                <h4>üîπ Using ioredis (cleaner)</h4>
                <div class="code-block">const redis = new Redis({
  host: "127.0.0.1",
  port: 6379,
});

<span class="checkmark">‚úî</span> Automatically connects
<span class="checkmark">‚úî</span> No need to call connect()
<span class="checkmark">‚úî</span> Cleaner and simpler</div>

                <h4>üîπ Using redis (node-redis)</h4>
                <div class="code-block">import { createClient } from "redis";

const client = createClient();
await client.connect();

<span class="crossmark">‚ùå</span> You must manually call connect()
<span class="crossmark">‚ùå</span> Slightly more setup</div>

                <div class="highlight">
                    <h4>üîπ Why You Used ioredis (Say This in Interview)</h4>
                    <p>I used <strong>ioredis</strong> because it provides better performance, built-in promise support, and strong support for Redis features like clustering and pub/sub. It also handles reconnection automatically, which is useful in production.</p>
                </div>

                <div class="note">
                    <h4>üîπ Performance Difference (IMPORTANT)</h4>
                    <p><strong>Say this confidently:</strong> ioredis is optimized for high-throughput and low-latency applications. It performs better under heavy load compared to basic Redis clients.</p>
                </div>

                <h3>üîπ How Redis is Actually Used After This Connection</h3>
                <div class="code-block">await redis.set("user:1", JSON.stringify(user));
const data = await redis.get("user:1");</div>
                <p>This is same for both libraries, only connection differs.</p>
            </div>

            <!-- Section 7 -->
            <div class="section">
                <h2>4Ô∏è‚É£ How I Used Redis (Step by Step)</h2>

                <h3>‚úÖ Step 1: Connect Redis</h3>
                <div class="code-block">const redis = require("redis");
const client = redis.createClient();
client.connect();</div>

                <h3>‚úÖ Step 2: Check Cache First</h3>
                <p><strong>Explanation:</strong> Before calling database, I first check if data exists in Redis.</p>
                <div class="code-block">const cachedData = await client.get("user:123");</div>

                <h3>‚úÖ Step 3: If Cache Exists (Cache Hit)</h3>
                <div class="code-block">if (cachedData) {
  return res.status(200).json(JSON.parse(cachedData));
}</div>
                <p>üëâ This avoids database call completely.</p>

                <h3>‚úÖ Step 4: If Cache Not Exists (Cache Miss)</h3>
                <div class="code-block">const user = await User.findById(id);

// save to redis for next time
await client.setEx("user:123", 3600, JSON.stringify(user));

res.status(200).json(user);</div>
            </div>

            <!-- Section 8 -->
            <div class="section">
                <h2>5Ô∏è‚É£ How Redis Improves Performance (With Numbers)</h2>
                <div class="highlight">
                    <p><strong>Say this confidently:</strong></p>
                    <p>After using Redis, API response time reduced from around <strong>300-500 ms</strong> to <strong>20-30 ms</strong> for cached requests.</p>
                </div>
            </div>

            <!-- Section 9 -->
            <div class="section">
                <h2>6Ô∏è‚É£ How I Checked / Verified Performance Improvement</h2>

                <h3>üîπ 1. Using Response Time (Browser / Postman)</h3>
                <ul>
                    <li>Checked API time before Redis</li>
                    <li>Checked API time after Redis</li>
                    <li>Compared response time in Postman / Network tab</li>
                </ul>

                <h3>üîπ 2. Logging Cache Hit / Miss</h3>
                <p>Check how many times cache hit:</p>
                <div class="code-block">if (cachedData) {
  console.log("Cache Hit");
} else {
  console.log("Cache Miss");
}</div>
                <p>üëâ This confirms Redis is working.</p>

                <h3>üîπ 3. Database Load Reduction</h3>
                <p><strong>Explanation:</strong> After Redis, database query count reduced because repeated requests were served from cache.</p>
            </div>

            <!-- Section 10 -->
            <div class="section">
                <h2>8Ô∏è‚É£ Error Handling</h2>
                <div class="code-block">try {
  // redis logic
} catch (error) {
  console.log("Redis error, fallback to DB");
}</div>
            </div>

            <!-- Section 11 -->
            <div class="section">
                <h2>üìç Where I used Redis in my MERN E-commerce Application?</h2>
                <p>Some API responses were being requested repeatedly, like:</p>
                <ul>
                    <li>User profile</li>
                    <li>College list</li>
                    <li>Dashboard data</li>
                    <li>OTP / session data</li>
                </ul>
                <p>Instead of fetching from database every time, I cached the data in Redis.</p>

                <h3>1. API Caching (Products, Categories, Trending items)</h3>
                <p>Frequently accessed API data stored in Redis to reduce MongoDB calls.</p>
                <div class="key-points">
                    <p><strong>Benefits:</strong></p>
                    <ul>
                        <li>Faster API response</li>
                        <li>Reduced MongoDB load</li>
                        <li>Lower server cost</li>
                    </ul>
                </div>

                <div class="example-box">
                    <h4>üìå Example: Caching Product List</h4>
                    <div class="code-block">// First check Redis
const cachedProducts = await redis.get("products:all");

if (cachedProducts) {
  return res.json(JSON.parse(cachedProducts));
}

// If not in cache, fetch from MongoDB
const products = await Product.find();

// Store in Redis with 1 hour expiry
await redis.setEx("products:all", 3600, JSON.stringify(products));

res.json(products);</div>
                </div>

                <h3>2. Session Storage</h3>
                <p>I stored JWT / session tokens in Redis with expiry.</p>
                <div class="key-points">
                    <p><strong>Benefits:</strong></p>
                    <ul>
                        <li>Fast access</li>
                        <li>Auto-expiry</li>
                        <li>Secure</li>
                        <li>Best for admin panel & cart sessions</li>
                    </ul>
                </div>

                <div class="example-box">
                    <h4>üìå Example: Storing User Session</h4>
                    <div class="code-block">// After successful login
const token = jwt.sign({ userId: user._id }, JWT_SECRET);

// Store in Redis with 24 hour expiry
await redis.setEx(`session:${user._id}`, 86400, token);

// Later, verify session
const storedToken = await redis.get(`session:${userId}`);
if (storedToken === providedToken) {
  // Valid session
}</div>
                </div>

                <h3>3. OTP System</h3>
                <p>Redis TTL is perfect for OTP.</p>
                <div class="code-block">SET otp:9876543210 1234 EX 120</div>
                <p>OTP expires in 2 minutes automatically.</p>

                <div class="example-box">
                    <h4>üìå Example: Complete OTP Flow</h4>
                    <div class="code-block">// 1. Generate and send OTP
const otp = Math.floor(100000 + Math.random() * 900000);
await redis.setEx(`otp:${email}`, 120, otp.toString());
// Send OTP via email/SMS

// 2. Verify OTP
const storedOtp = await redis.get(`otp:${email}`);
if (storedOtp === providedOtp) {
  // OTP verified, delete from Redis
  await redis.del(`otp:${email}`);
  // Proceed with registration/login
}</div>
                </div>

                <h3>4. Rate Limiting</h3>
                <p>Prevent multiple OTP/login hits from same IP.</p>
                <div class="code-block">INCR ip:1234
EXPIRE ip:1234 60</div>
                <p>Used for security and preventing abuse.</p>

                <div class="example-box">
                    <h4>üìå Example: IP-based Rate Limiting</h4>
                    <div class="code-block">// Middleware for rate limiting
const rateLimiter = async (req, res, next) => {
  const ip = req.ip;
  const key = `rate:${ip}`;
  
  const requests = await redis.incr(key);
  
  if (requests === 1) {
    // First request, set expiry of 60 seconds
    await redis.expire(key, 60);
  }
  
  if (requests > 10) {
    return res.status(429).json({ 
      message: "Too many requests, try again later" 
    });
  }
  
  next();
};</div>
                </div>
            </div>

            <!-- Section 12 -->
            <div class="section">
                <h2>üîê How JWT is Stored and Used</h2>
                <p>Instead of checking the database on every request, we validate the JWT and then directly check Redis using userId or token. This avoids unnecessary database calls and improves performance.</p>

                <h3>2Ô∏è‚É£ JWT Token Flow (How Same User is Identified)</h3>
                <h4>üîπ What happens after login</h4>
                <p>After successful login:</p>
                <div class="code-block">const token = jwt.sign(
  { 
    userId: user._id, 
    email: user.email 
  },
  process.env.JWT_SECRET,
  { expiresIn: "1d" }
);</div>
                <p>This JWT uniquely identifies the user.</p>

                <h3>3Ô∏è‚É£ Storing JWT in Redis (Optional but Powerful)</h3>
                <h4>üîπ Why store JWT in Redis?</h4>
                <ul>
                    <li>Logout support</li>
                    <li>Token invalidation</li>
                    <li>Faster validation</li>
                    <li>Security</li>
                </ul>

                <h4>üîπ Store JWT in Redis</h4>
                <div class="code-block">await redis.setEx(
  `jwt:${user._id}`,
  86400, // 1 day
  token
);</div>
                <p>üëâ Key is based on userId<br>
                üëâ This ensures same user ‚Üí same key</p>

                <h3>4Ô∏è‚É£ When Request Comes from Same User</h3>
                <h4>üîπ Request flow</h4>
                <p>Client sends request with token:</p>
                <div class="code-block">Authorization: Bearer &lt;token&gt;</div>
                <p>Backend extracts token:</p>
                <div class="code-block">const token = req.headers.authorization.split(" ")[1];</div>

                <h3>5Ô∏è‚É£ Validate User using JWT</h3>
                <h4>üîπ Decode JWT</h4>
                <div class="code-block">const decoded = jwt.verify(token, process.env.JWT_SECRET);</div>
                <p>Now we know: <code>decoded.userId</code><br>
                üëâ This tells which user sent the request</p>

                <h3>6Ô∏è‚É£ Check Redis Cache Directly (FAST üî•)</h3>
                <div class="code-block">const cachedToken = await redis.get(`jwt:${decoded.userId}`);

if (!cachedToken || cachedToken !== token) {
  return res.status(401).json({ message: "Unauthorized" });
}</div>
                <p>‚úÖ Token exists ‚Üí user is valid<br>
                ‚ùå Not exists ‚Üí token revoked / expired</p>

                <h3>7Ô∏è‚É£ Why This Is Fast (Performance)</h3>
                <div class="highlight">
                    <p><strong>Without Redis:</strong><br>
                    Request ‚Üí JWT verify ‚Üí DB lookup ‚Üí Response</p>
                    <p><strong>With Redis:</strong><br>
                    Request ‚Üí JWT verify ‚Üí Redis check ‚Üí Response</p>
                    <p>üëâ Redis is in-memory, so response is very fast</p>
                </div>

                <h3>8Ô∏è‚É£ How We Know Request Is From Same User</h3>
                <div class="note">
                    <p><strong>Answer this clearly:</strong></p>
                    <p>The JWT contains <code>userId</code>. I extract <code>userId</code> from JWT and use it as Redis key. If the token exists in Redis for that <code>userId</code>, I allow the request.</p>
                </div>

                <h3>9Ô∏è‚É£ Logout Case (Extra Marks ‚≠ê)</h3>
                <div class="code-block">await redis.del(`jwt:${userId}`);</div>
                <p>üëâ Token is removed<br>
                üëâ User is logged out instantly</p>

                <h3>üßæ Database Is Used Only When Needed</h3>
                <div class="example-box">
                    <h4>Example: When to use Database</h4>
                    <ul>
                        <li>First login</li>
                        <li>Profile update</li>
                        <li>Fetch fresh data</li>
                    </ul>
                    <h4>Not for:</h4>
                    <ul>
                        <li>Auth validation</li>
                        <li>Session check</li>
                    </ul>
                </div>
            </div>

            <!-- Section 13: NEW OTP SECTION -->
           <!-- Section 13 -->
<div class="section">
  <h2>üîê How OTP is Stored (Important Interview Question)</h2>

  <p>
    When we store OTP, the user is <strong>not logged in yet</strong>.
    So a common interview question is:
  </p>

  <div class="highlight">
    <p>
      ‚ùì How do we know which user the OTP belongs to when there is no JWT?
    </p>
  </div>

  <p>
    ‚úÖ <strong>Answer:</strong>  
    We store OTP in Redis using a <strong>temporary identifier</strong> such as
    <strong>Email</strong> or <strong>Phone Number</strong>.  
    JWT is created <strong>only after OTP verification</strong>.
  </p>

  <h3>üîê Correct OTP Flow (Step by Step)</h3>

  <h4>1Ô∏è‚É£ User Requests OTP (User Not Logged In Yet)</h4>
  <ul>
    <li>No JWT ‚ùå</li>
    <li>User is not authenticated ‚ùå</li>
    <li>But we know user's <strong>Email or Phone</strong> ‚úÖ</li>
  </ul>

  <p>
    üëâ Email / Phone becomes the <strong>identifier</strong>.
  </p>

  <h4>2Ô∏è‚É£ How OTP Is Stored (Key Idea)</h4>
  <p>
    We store OTP in Redis using Email or Phone as the key.
  </p>

  <div class="code-block">
await redis.setEx(
  `otp:${email}`,
  300, // 5 minutes
  generatedOtp
);
  </div>

  <p>
    üîé Meaning:
  </p>
  <ul>
    <li><strong>Key:</strong> otp:user@email.com</li>
    <li><strong>Value:</strong> 123456</li>
    <li><strong>TTL:</strong> Auto delete after 5 minutes</li>
  </ul>

  <p>
    üëâ OTP is linked to <strong>Email / Phone</strong>, not JWT.
  </p>

  <h4>3Ô∏è‚É£ How OTP Is Verified</h4>
  <p>User sends:</p>

  <div class="code-block">
{
  "email": "user@email.com",
  "otp": "123456"
}
  </div>

  <p>Backend logic:</p>

  <div class="code-block">
const savedOtp = await redis.get(`otp:${email}`);

if (savedOtp === enteredOtp) {
  // OTP verified
}
  </div>

  <p>
    ‚úÖ Same email ‚Üí same Redis key ‚Üí OTP matched  
    üëâ Now we know OTP belongs to this user
  </p>

  <h4>4Ô∏è‚É£ After OTP Verification (IMPORTANT)</h4>
  <ul>
    <li>Create user (signup) OR</li>
    <li>Authenticate user (login)</li>
    <li>Generate JWT</li>
  </ul>

  <div class="code-block">
const token = jwt.sign(
  { userId: user._id },
  JWT_SECRET,
  { expiresIn: "1d" }
);
  </div>

  <div class="note">
    üëâ OTP flow ends here  
    üëâ JWT flow starts here
  </div>
</div>

<!-- Section 14 -->
<div class="section">
  <h2>üß± How Products and User Profiles Are Stored</h2>

  <h3>‚úÖ High Level Answer (Interview)</h3>
  <ul>
    <li>Products are stored by <strong>productId</strong></li>
    <li>User profile stores only <strong>references (IDs)</strong></li>
  </ul>

  <h3>üì¶ Product Storage (Database)</h3>
  <div class="code-block">
{
  "_id": "p123",
  "name": "Laptop",
  "price": 50000,
  "category": "Electronics"
}
  </div>

  <p>üìå Each product has its own unique <strong>productId</strong></p>

  <h3>üë§ User Profile Storage (Database)</h3>
  <div class="code-block">
{
  "_id": "u101",
  "name": "Nikhil",
  "email": "nikhil@email.com",
  "cart": ["p123", "p456"]
}
  </div>

  <p>
    üëâ User does NOT store product data  
    üëâ User stores only product IDs
  </p>
</div>

<!-- Section 15 -->
<div class="section">
  <h2>‚ö° How Redis Is Used with Products & User Profile</h2>

  <h3>üîπ Product Caching</h3>
  <div class="code-block">
await redis.setEx(
  `product:p123`,
  3600,
  JSON.stringify(product)
);
  </div>

  <p>When request comes:</p>

  <div class="code-block">
const cachedProduct = await redis.get("product:p123");
  </div>

  <ul>
    <li>‚úî Fast access</li>
    <li>‚úî No database hit</li>
  </ul>

  <h3>üîπ User Profile Caching</h3>
  <div class="code-block">
await redis.setEx(
  `user:u101`,
  3600,
  JSON.stringify(userProfile)
);
  </div>

  <p>
    Request flow:
  </p>

  <div class="note">
    JWT ‚Üí extract userId ‚Üí check Redis ‚Üí return profile
  </div>
</div>

<!-- Section 16 -->
<div class="section">
  <h2>üñ•Ô∏è Where Redis Runs (Very Important)</h2>

  <h3>üîπ How Redis Actually Runs</h3>
  <ul>
    <li>Redis is a separate service</li>
    <li>Runs as a different process</li>
    <li>Often on a different server</li>
    <li>Same machine only for local development</li>
  </ul>

  <h3>üîπ Request Flow</h3>
  <div class="flow-diagram">
    <span class="flow-step">Client</span>
    <span class="arrow">‚Üì</span>
    <span class="flow-step">Backend API</span>
    <span class="arrow">‚Üì</span>
    <span class="flow-step">Redis Server</span>
    <span class="arrow">‚Üì</span>
    <span class="flow-step">Backend API</span>
    <span class="arrow">‚Üì</span>
    <span class="flow-step">Client</span>
  </div>

  <p>
    ‚ùå Client never talks to Redis  
    ‚úî Only backend talks to Redis
  </p>

  <h3>üîπ If User Does NOT Have Redis Installed?</h3>
  <ul>
    <li>User does NOT need Redis ‚ùå</li>
    <li>Browser/mobile app does NOT need Redis ‚ùå</li>
    <li>Only backend needs Redis ‚úÖ</li>
  </ul>

  <h3>üîπ Where Redis Data Is Stored?</h3>
  <div class="highlight">
    <p>
      Redis stores data in the <strong>RAM of the machine</strong> where Redis is installed.
    </p>
    <p>
      ‚ùå Not MongoDB  
      ‚ùå Not disk (except backup)  
      ‚úî RAM only
    </p>
  </div>
</div>
